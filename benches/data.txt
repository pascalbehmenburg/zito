use std::collections::HashMap;

type FileId = u32;
type Offset = u32;
type Trigram = [u8; 3]; // much better than &str for binary perf

// # n-grams / trigrams
// implementing n-grams based on stanford "speech and language processing" book
// https://web.stanford.edu/~jurafsky/slp3/
// specifically https://web.stanford.edu/~jurafsky/slp3/3.pdf
// https://en.wikipedia.org/wiki/Trigram_search
// colin353 implemented a code search engine based on trigrams:
// https://medium.com/@colin353/code-search-74a6a0a74789
// https://docs.rs/trigram/0.4.3/src/trigram/lib.rs.html#105
// google describing their old search engine:
// https://swtch.com/~rsc/regexp/regexp4.html

// infos on how the google search architecture might work:
// http://infolab.stanford.edu/~backrub/google.html
// when deeplearning met codesearch - evaluating deep learning for code search by facebook
// https://arxiv.org/pdf/1905.03813v4

// evaluate
// daachorse: Double-Array Aho-Corasick
// https://github.com/daac-tools/daachorse
// https://arxiv.org/abs/2207.13870
// which claims to be 2.6x faster than aho-corasick
// https://github.com/BurntSushi/aho-corasick
fn index_file(
    trigram_index: &mut HashMap<Trigram, Vec<(FileId, Offset)>>,
    file_id: FileId,
    content: &[u8],
) {
    let mut window = [0u8; 3];
    let mut count = 0;

    for (offset, &byte) in content.iter().enumerate() {
        if byte == b'\n' || byte == b'\r' || byte == b'\t' {
            continue;
        }

        window[count % 3] = byte;
        count += 1;

        if count >= 3 {
            let trigram = [window[0], window[1], window[2]];
            trigram_index
                .entry(trigram)
                .or_default()
                .push((file_id, (offset + 1 - 3) as u32));
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use quickcheck::quickcheck;

    #[test]
    fn test_empty_content() {
        let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
        index_file(&mut trigram_index, 0, b"");
        assert!(
            trigram_index.is_empty(),
            "Index should be empty for empty content"
        );
    }

    #[test]
    fn test_content_with_less_than_three_valid_chars() {
        let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
        index_file(&mut trigram_index, 0, b"\n\t\r");
        assert!(
            trigram_index.is_empty(),
            "Index should be empty for content with fewer than three valid characters"
        );
    }

    #[test]
    fn test_content_with_exactly_three_valid_chars() {
        let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
        index_file(&mut trigram_index, 0, b"a\nb\rc");
        assert_eq!(
            trigram_index.len(),
            1,
            "Index should contain exactly one trigram for three valid characters"
        );
        assert!(trigram_index.contains_key(&[b'a', b'b', b'c']));
    }

    #[test]
    fn test_content_with_multiple_trigrams() {
        let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
        index_file(&mut trigram_index, 0, b"the quick brown fox");
        assert!(trigram_index.contains_key(&[b't', b'h', b'e']));
        assert!(trigram_index.contains_key(&[b'h', b'e', b' ']));
        assert!(trigram_index.contains_key(&[b'q', b'u', b'i']));
    }

    #[test]
    fn test_content_with_whitespace() {
        let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
        index_file(&mut trigram_index, 0, b"the\n\tquick\rfox");
        assert!(trigram_index.contains_key(&[b't', b'h', b'e']));
        assert!(trigram_index.contains_key(&[b'q', b'u', b'i']));
        assert!(trigram_index.contains_key(&[b'u', b'i', b'c']));
    }

    #[test]
    fn test_offsets_are_correct() {
        let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
        index_file(&mut trigram_index, 0, b"the quick");
        assert_eq!(
            trigram_index[&[b't', b'h', b'e']],
            vec![(0, 0)],
            "Offset for 'the' should be 0"
        );
        assert_eq!(
            trigram_index[&[b'h', b'e', b' ']],
            vec![(0, 1)],
            "Offset for 'he ' should be 1"
        );
    }

    // Property-based testing using QuickCheck
    quickcheck! {
        fn test_no_trigrams_for_short_content(content: Vec<u8>) -> bool {
            let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
            index_file(&mut trigram_index, 0, &content);
            if content.iter().filter(|&&c| c != b'\n' && c != b'\r' && c != b'\t').count() < 3 {
                trigram_index.is_empty()
            } else {
                true
            }
        }

        fn test_trigrams_are_correctly_generated(content: Vec<u8>) -> bool {
            let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
            index_file(&mut trigram_index, 0, &content);

            let mut expected_trigrams = Vec::new();
            let mut window = Vec::new();

            for &c in content.iter() {
                if c == b'\n' || c == b'\r' || c == b'\t' {
                    continue;
                }
                window.push(c);
                if window.len() == 3 {
                    expected_trigrams.push(window.clone());
                    window.remove(0);
                }
            }

            // Check that all expected trigrams are in the index
            let all_trigrams_present = expected_trigrams.iter().all(|trigram| {
                trigram_index.contains_key(&[trigram[0], trigram[1], trigram[2]])
            });

            // Check that the index doesn't contain unexpected trigrams
            let no_extra_trigrams = trigram_index.keys().all(|key| {
                expected_trigrams.contains(&key.to_vec())
            });

            all_trigrams_present && no_extra_trigrams
        }
    }
}

const EXAMPLE: &str = include_str!("main.rs");
fn main() {
    let mut trigram_index: HashMap<Trigram, Vec<(FileId, Offset)>> = HashMap::new();
    index_file(&mut trigram_index, 0, EXAMPLE.as_bytes());
}
